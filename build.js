#!/usr/bin/env node

'use strict';

var bs = require('browser-sync');
var chokidar = require('chokidar');
var fs = require('graceful-fs-extra');
var chalk = require('chalk');
var uuid = require('node-uuid');

var cp = require('child_process');
var exec = cp.exec;
// var spawn = cp.spawn;

var config = {
  browserSync: {
    server: {
      baseDir: 'bin/web',
      routes: { }
    },
    ghostMode: false,
    online: false,
    injectChanges: false,
    minify: false
  },
  watch: {
    srcDir: 'src',
    assetsDir: 'assets'
  }
};

// Source maps are borked for me as generated by Haxe, which uses 'file:///'
// as the sourceRoot. The lazy solution seems to be to make a route that maps
// to our filesystem root (since Haxe sources are located in either the haxe stdlib
// directory, the haxelib directory, or the project directory.)

// That this is kind of a huge security risk, so we generate a new uuid each run to
// use as a route mapping.

// A more secure solution might be to only allow mapping to those three required directories, but enh.
var routeUuid = uuid.v4();
config.browserSync.server.routes['/' + routeUuid] = '/';


// config.flow = JSON.parse(fs.readFileSync('project.flow'));

var tasks = {
  flow: function(cb) {
    exec("haxelib run flow build web", function (error, stdout, stderr) {
      if(stdout) {
        console.log(stdout.split('\n').map(function(line) { return chalk.blue('[flow]') + ' stdout: ' + line; }).join('\n'));
      }
      if(stderr) {
        console.log(stderr.split('\n').map(function(line) { return chalk.blue('[flow]') + ' stderr: ' + line; }).join('\n'));
      }
      if(cb) {
        cb(error);
      }
    });
  },
  fixHxml: function() {
    var hxml = fs.readFileSync('bin/web.build/build.hxml', { encoding: 'utf8' });
    var lines = hxml.split('\n');
    if(lines.indexOf('-debug') === -1) {
      lines.push('-debug');
      fs.writeFileSync('bin/web.build/build.hxml', lines.join('\n'));
      console.log('added debug flag to hxml.');
    }
  },
  haxe: function(cb) {
    exec("haxe bin/web.build/build.hxml", function (error, stdout, stderr) {
      if(stdout) {
        console.log(stdout.split('\n').map(function(line) { return chalk.blue('[haxe]') + ' stdout: ' + line; }).join('\n'));
      }
      if(stderr) {
        console.log(stderr.split('\n').map(function(line) { return chalk.blue('[haxe]') + ' stderr: ' + line; }).join('\n'));
      }
      if(!error) {
        console.log(chalk.blue('[haxe]') + ' executed without errors.');
        var sourceMapFiles = fs.readdirSync('bin/web/').filter(function(fn) { return endsWith(fn, '.js.map'); });
        sourceMapFiles.forEach(function(fn) {
          var map = fs.readJSONSync('bin/web/' + fn);
          map.sourceRoot = routeUuid;
          fs.writeJSONSync('bin/web/' + fn, map);
          console.log(chalk.blue('[haxe]') + ' rewrote source map for ' + fn);
        });
      }
      if(cb) {
        cb(error);
      }
    });
  },
  watch: function() {
    var watcher = chokidar.watch([config.watch.srcDir, config.watch.assetsDir], {
      ignored: /[\/\\]\./,
      ignoreInitial: true
    });

    function reload() {
      if(bs.active) {
        console.log(chalk.blue('[watch]') + ' Reloading at ' + new Date());
        bs.reload();
      }
    }

    // var cwd = process.cwd();

    watcher.on('all', function(event, path) {
      console.log(chalk.blue('[watch]') + ' ' + path + ' -> ' + event);
      if(startsWith(path, config.watch.srcDir)) {
        tasks.haxe(function(e) {
          if(e) {
            console.error(chalk.blue('[haxe]') + ' error: ' + e);
            if(bs.active) {
              bs.notify('[haxe] error: <br><br>' + e.toString().split('\n').join('<br><br>'), 10000);
            }
          }
          else {
            reload();
          }
        });
      }
      /*
      //logic for handling asset modification:
      else {
        switch(event) {
          case 'add':
            // fs.copy
            break;
          case 'addDir':

            break;
          case 'change':

            break;
          case 'unlink':

            break;
          case 'unlinkDir':

            break;
          default:
            throw "Unhandled Chokidar event!";
        }
      }
      */
    })
    .on('error', function(err) {
      var msg = '[watch] error: ' + err.message;
      console.error(msg);
      if(bs.active) {
        // set a timeout, because the initial 'BrowserSync connected'
        // message helpfully squashes any other notifications on reload
        setTimeout(function() {
          bs.notify(msg, 10000);
        }, 1000);
      }
    });
  },
  serve: function() {
    tasks.flow(function(e) {
      if(e) {
        console.error(chalk.blue('[flow]') + ' error: ' + e);
      }
      else {
        tasks.fixHxml();
        tasks.haxe(function(e) {
          if(e) {
            console.error(chalk.blue('[haxe]') + ' error: ' + e);
          }
          else {
            tasks.watch();
            bs(config.browserSync);
          }
        });
      }
    });
  }
};

var task = process.argv.slice(2)[0];
if(!(task in tasks)) {
  console.log(
    'Invalid task! Possible tasks are:\n' +
    Object.keys(tasks).map(function(t) { return ' - ' + t; }).join('\n'));
}
else {
  tasks[task]();
}

function endsWith(s, search) { return s.indexOf(search, s.length - search.length) !== -1; }
function startsWith(s, search) { return s.lastIndexOf(search, 0) === 0; }
